// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'update_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$UpdateState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateStateCopyWith<$Res> {
  factory $UpdateStateCopyWith(
    UpdateState value,
    $Res Function(UpdateState) then,
  ) = _$UpdateStateCopyWithImpl<$Res, UpdateState>;
}

/// @nodoc
class _$UpdateStateCopyWithImpl<$Res, $Val extends UpdateState>
    implements $UpdateStateCopyWith<$Res> {
  _$UpdateStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$UpdateInitialImplCopyWith<$Res> {
  factory _$$UpdateInitialImplCopyWith(
    _$UpdateInitialImpl value,
    $Res Function(_$UpdateInitialImpl) then,
  ) = __$$UpdateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UpdateInitialImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateInitialImpl>
    implements _$$UpdateInitialImplCopyWith<$Res> {
  __$$UpdateInitialImplCopyWithImpl(
    _$UpdateInitialImpl _value,
    $Res Function(_$UpdateInitialImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UpdateInitialImpl implements UpdateInitial {
  const _$UpdateInitialImpl();

  @override
  String toString() {
    return 'UpdateState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UpdateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class UpdateInitial implements UpdateState {
  const factory UpdateInitial() = _$UpdateInitialImpl;
}

/// @nodoc
abstract class _$$UpdateCheckingImplCopyWith<$Res> {
  factory _$$UpdateCheckingImplCopyWith(
    _$UpdateCheckingImpl value,
    $Res Function(_$UpdateCheckingImpl) then,
  ) = __$$UpdateCheckingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UpdateCheckingImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateCheckingImpl>
    implements _$$UpdateCheckingImplCopyWith<$Res> {
  __$$UpdateCheckingImplCopyWithImpl(
    _$UpdateCheckingImpl _value,
    $Res Function(_$UpdateCheckingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UpdateCheckingImpl implements UpdateChecking {
  const _$UpdateCheckingImpl();

  @override
  String toString() {
    return 'UpdateState.checking()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UpdateCheckingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return checking();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return checking?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (checking != null) {
      return checking();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return checking(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return checking?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (checking != null) {
      return checking(this);
    }
    return orElse();
  }
}

abstract class UpdateChecking implements UpdateState {
  const factory UpdateChecking() = _$UpdateCheckingImpl;
}

/// @nodoc
abstract class _$$UpdateIsAvailableImplCopyWith<$Res> {
  factory _$$UpdateIsAvailableImplCopyWith(
    _$UpdateIsAvailableImpl value,
    $Res Function(_$UpdateIsAvailableImpl) then,
  ) = __$$UpdateIsAvailableImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UpdateInfo info});

  $UpdateInfoCopyWith<$Res> get info;
}

/// @nodoc
class __$$UpdateIsAvailableImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateIsAvailableImpl>
    implements _$$UpdateIsAvailableImplCopyWith<$Res> {
  __$$UpdateIsAvailableImplCopyWithImpl(
    _$UpdateIsAvailableImpl _value,
    $Res Function(_$UpdateIsAvailableImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? info = null}) {
    return _then(
      _$UpdateIsAvailableImpl(
        null == info
            ? _value.info
            : info // ignore: cast_nullable_to_non_nullable
                  as UpdateInfo,
      ),
    );
  }

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UpdateInfoCopyWith<$Res> get info {
    return $UpdateInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

/// @nodoc

class _$UpdateIsAvailableImpl implements UpdateIsAvailable {
  const _$UpdateIsAvailableImpl(this.info);

  @override
  final UpdateInfo info;

  @override
  String toString() {
    return 'UpdateState.updateAvailable(info: $info)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateIsAvailableImpl &&
            (identical(other.info, info) || other.info == info));
  }

  @override
  int get hashCode => Object.hash(runtimeType, info);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateIsAvailableImplCopyWith<_$UpdateIsAvailableImpl> get copyWith =>
      __$$UpdateIsAvailableImplCopyWithImpl<_$UpdateIsAvailableImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return updateAvailable(info);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return updateAvailable?.call(info);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (updateAvailable != null) {
      return updateAvailable(info);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return updateAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return updateAvailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (updateAvailable != null) {
      return updateAvailable(this);
    }
    return orElse();
  }
}

abstract class UpdateIsAvailable implements UpdateState {
  const factory UpdateIsAvailable(final UpdateInfo info) =
      _$UpdateIsAvailableImpl;

  UpdateInfo get info;

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateIsAvailableImplCopyWith<_$UpdateIsAvailableImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateUpToDateImplCopyWith<$Res> {
  factory _$$UpdateUpToDateImplCopyWith(
    _$UpdateUpToDateImpl value,
    $Res Function(_$UpdateUpToDateImpl) then,
  ) = __$$UpdateUpToDateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String version});
}

/// @nodoc
class __$$UpdateUpToDateImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateUpToDateImpl>
    implements _$$UpdateUpToDateImplCopyWith<$Res> {
  __$$UpdateUpToDateImplCopyWithImpl(
    _$UpdateUpToDateImpl _value,
    $Res Function(_$UpdateUpToDateImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? version = null}) {
    return _then(
      _$UpdateUpToDateImpl(
        null == version
            ? _value.version
            : version // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc

class _$UpdateUpToDateImpl implements UpdateUpToDate {
  const _$UpdateUpToDateImpl(this.version);

  @override
  final String version;

  @override
  String toString() {
    return 'UpdateState.upToDate(version: $version)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateUpToDateImpl &&
            (identical(other.version, version) || other.version == version));
  }

  @override
  int get hashCode => Object.hash(runtimeType, version);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateUpToDateImplCopyWith<_$UpdateUpToDateImpl> get copyWith =>
      __$$UpdateUpToDateImplCopyWithImpl<_$UpdateUpToDateImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return upToDate(version);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return upToDate?.call(version);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (upToDate != null) {
      return upToDate(version);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return upToDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return upToDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (upToDate != null) {
      return upToDate(this);
    }
    return orElse();
  }
}

abstract class UpdateUpToDate implements UpdateState {
  const factory UpdateUpToDate(final String version) = _$UpdateUpToDateImpl;

  String get version;

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateUpToDateImplCopyWith<_$UpdateUpToDateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateDownloadingImplCopyWith<$Res> {
  factory _$$UpdateDownloadingImplCopyWith(
    _$UpdateDownloadingImpl value,
    $Res Function(_$UpdateDownloadingImpl) then,
  ) = __$$UpdateDownloadingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UpdateInfo info, int bytesReceived, int totalBytes});

  $UpdateInfoCopyWith<$Res> get info;
}

/// @nodoc
class __$$UpdateDownloadingImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateDownloadingImpl>
    implements _$$UpdateDownloadingImplCopyWith<$Res> {
  __$$UpdateDownloadingImplCopyWithImpl(
    _$UpdateDownloadingImpl _value,
    $Res Function(_$UpdateDownloadingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? info = null,
    Object? bytesReceived = null,
    Object? totalBytes = null,
  }) {
    return _then(
      _$UpdateDownloadingImpl(
        info: null == info
            ? _value.info
            : info // ignore: cast_nullable_to_non_nullable
                  as UpdateInfo,
        bytesReceived: null == bytesReceived
            ? _value.bytesReceived
            : bytesReceived // ignore: cast_nullable_to_non_nullable
                  as int,
        totalBytes: null == totalBytes
            ? _value.totalBytes
            : totalBytes // ignore: cast_nullable_to_non_nullable
                  as int,
      ),
    );
  }

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UpdateInfoCopyWith<$Res> get info {
    return $UpdateInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

/// @nodoc

class _$UpdateDownloadingImpl implements UpdateDownloading {
  const _$UpdateDownloadingImpl({
    required this.info,
    required this.bytesReceived,
    required this.totalBytes,
  });

  @override
  final UpdateInfo info;
  @override
  final int bytesReceived;
  @override
  final int totalBytes;

  @override
  String toString() {
    return 'UpdateState.downloading(info: $info, bytesReceived: $bytesReceived, totalBytes: $totalBytes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateDownloadingImpl &&
            (identical(other.info, info) || other.info == info) &&
            (identical(other.bytesReceived, bytesReceived) ||
                other.bytesReceived == bytesReceived) &&
            (identical(other.totalBytes, totalBytes) ||
                other.totalBytes == totalBytes));
  }

  @override
  int get hashCode => Object.hash(runtimeType, info, bytesReceived, totalBytes);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateDownloadingImplCopyWith<_$UpdateDownloadingImpl> get copyWith =>
      __$$UpdateDownloadingImplCopyWithImpl<_$UpdateDownloadingImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return downloading(info, bytesReceived, totalBytes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return downloading?.call(info, bytesReceived, totalBytes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (downloading != null) {
      return downloading(info, bytesReceived, totalBytes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return downloading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return downloading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (downloading != null) {
      return downloading(this);
    }
    return orElse();
  }
}

abstract class UpdateDownloading implements UpdateState {
  const factory UpdateDownloading({
    required final UpdateInfo info,
    required final int bytesReceived,
    required final int totalBytes,
  }) = _$UpdateDownloadingImpl;

  UpdateInfo get info;
  int get bytesReceived;
  int get totalBytes;

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateDownloadingImplCopyWith<_$UpdateDownloadingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateExtractingImplCopyWith<$Res> {
  factory _$$UpdateExtractingImplCopyWith(
    _$UpdateExtractingImpl value,
    $Res Function(_$UpdateExtractingImpl) then,
  ) = __$$UpdateExtractingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UpdateInfo info});

  $UpdateInfoCopyWith<$Res> get info;
}

/// @nodoc
class __$$UpdateExtractingImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateExtractingImpl>
    implements _$$UpdateExtractingImplCopyWith<$Res> {
  __$$UpdateExtractingImplCopyWithImpl(
    _$UpdateExtractingImpl _value,
    $Res Function(_$UpdateExtractingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? info = null}) {
    return _then(
      _$UpdateExtractingImpl(
        info: null == info
            ? _value.info
            : info // ignore: cast_nullable_to_non_nullable
                  as UpdateInfo,
      ),
    );
  }

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UpdateInfoCopyWith<$Res> get info {
    return $UpdateInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

/// @nodoc

class _$UpdateExtractingImpl implements UpdateExtracting {
  const _$UpdateExtractingImpl({required this.info});

  @override
  final UpdateInfo info;

  @override
  String toString() {
    return 'UpdateState.extracting(info: $info)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateExtractingImpl &&
            (identical(other.info, info) || other.info == info));
  }

  @override
  int get hashCode => Object.hash(runtimeType, info);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateExtractingImplCopyWith<_$UpdateExtractingImpl> get copyWith =>
      __$$UpdateExtractingImplCopyWithImpl<_$UpdateExtractingImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return extracting(info);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return extracting?.call(info);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (extracting != null) {
      return extracting(info);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return extracting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return extracting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (extracting != null) {
      return extracting(this);
    }
    return orElse();
  }
}

abstract class UpdateExtracting implements UpdateState {
  const factory UpdateExtracting({required final UpdateInfo info}) =
      _$UpdateExtractingImpl;

  UpdateInfo get info;

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateExtractingImplCopyWith<_$UpdateExtractingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateInstallingImplCopyWith<$Res> {
  factory _$$UpdateInstallingImplCopyWith(
    _$UpdateInstallingImpl value,
    $Res Function(_$UpdateInstallingImpl) then,
  ) = __$$UpdateInstallingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UpdateInfo info});

  $UpdateInfoCopyWith<$Res> get info;
}

/// @nodoc
class __$$UpdateInstallingImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateInstallingImpl>
    implements _$$UpdateInstallingImplCopyWith<$Res> {
  __$$UpdateInstallingImplCopyWithImpl(
    _$UpdateInstallingImpl _value,
    $Res Function(_$UpdateInstallingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? info = null}) {
    return _then(
      _$UpdateInstallingImpl(
        info: null == info
            ? _value.info
            : info // ignore: cast_nullable_to_non_nullable
                  as UpdateInfo,
      ),
    );
  }

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UpdateInfoCopyWith<$Res> get info {
    return $UpdateInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

/// @nodoc

class _$UpdateInstallingImpl implements UpdateInstalling {
  const _$UpdateInstallingImpl({required this.info});

  @override
  final UpdateInfo info;

  @override
  String toString() {
    return 'UpdateState.installing(info: $info)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateInstallingImpl &&
            (identical(other.info, info) || other.info == info));
  }

  @override
  int get hashCode => Object.hash(runtimeType, info);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateInstallingImplCopyWith<_$UpdateInstallingImpl> get copyWith =>
      __$$UpdateInstallingImplCopyWithImpl<_$UpdateInstallingImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return installing(info);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return installing?.call(info);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (installing != null) {
      return installing(info);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return installing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return installing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (installing != null) {
      return installing(this);
    }
    return orElse();
  }
}

abstract class UpdateInstalling implements UpdateState {
  const factory UpdateInstalling({required final UpdateInfo info}) =
      _$UpdateInstallingImpl;

  UpdateInfo get info;

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateInstallingImplCopyWith<_$UpdateInstallingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateIsCompletedImplCopyWith<$Res> {
  factory _$$UpdateIsCompletedImplCopyWith(
    _$UpdateIsCompletedImpl value,
    $Res Function(_$UpdateIsCompletedImpl) then,
  ) = __$$UpdateIsCompletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UpdateInfo info});

  $UpdateInfoCopyWith<$Res> get info;
}

/// @nodoc
class __$$UpdateIsCompletedImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateIsCompletedImpl>
    implements _$$UpdateIsCompletedImplCopyWith<$Res> {
  __$$UpdateIsCompletedImplCopyWithImpl(
    _$UpdateIsCompletedImpl _value,
    $Res Function(_$UpdateIsCompletedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? info = null}) {
    return _then(
      _$UpdateIsCompletedImpl(
        info: null == info
            ? _value.info
            : info // ignore: cast_nullable_to_non_nullable
                  as UpdateInfo,
      ),
    );
  }

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UpdateInfoCopyWith<$Res> get info {
    return $UpdateInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

/// @nodoc

class _$UpdateIsCompletedImpl implements UpdateIsCompleted {
  const _$UpdateIsCompletedImpl({required this.info});

  @override
  final UpdateInfo info;

  @override
  String toString() {
    return 'UpdateState.completed(info: $info)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateIsCompletedImpl &&
            (identical(other.info, info) || other.info == info));
  }

  @override
  int get hashCode => Object.hash(runtimeType, info);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateIsCompletedImplCopyWith<_$UpdateIsCompletedImpl> get copyWith =>
      __$$UpdateIsCompletedImplCopyWithImpl<_$UpdateIsCompletedImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return completed(info);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return completed?.call(info);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(info);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class UpdateIsCompleted implements UpdateState {
  const factory UpdateIsCompleted({required final UpdateInfo info}) =
      _$UpdateIsCompletedImpl;

  UpdateInfo get info;

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateIsCompletedImplCopyWith<_$UpdateIsCompletedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateErrorImplCopyWith<$Res> {
  factory _$$UpdateErrorImplCopyWith(
    _$UpdateErrorImpl value,
    $Res Function(_$UpdateErrorImpl) then,
  ) = __$$UpdateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$UpdateErrorImplCopyWithImpl<$Res>
    extends _$UpdateStateCopyWithImpl<$Res, _$UpdateErrorImpl>
    implements _$$UpdateErrorImplCopyWith<$Res> {
  __$$UpdateErrorImplCopyWithImpl(
    _$UpdateErrorImpl _value,
    $Res Function(_$UpdateErrorImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? message = null}) {
    return _then(
      _$UpdateErrorImpl(
        null == message
            ? _value.message
            : message // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc

class _$UpdateErrorImpl implements UpdateError {
  const _$UpdateErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'UpdateState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateErrorImplCopyWith<_$UpdateErrorImpl> get copyWith =>
      __$$UpdateErrorImplCopyWithImpl<_$UpdateErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() checking,
    required TResult Function(UpdateInfo info) updateAvailable,
    required TResult Function(String version) upToDate,
    required TResult Function(
      UpdateInfo info,
      int bytesReceived,
      int totalBytes,
    )
    downloading,
    required TResult Function(UpdateInfo info) extracting,
    required TResult Function(UpdateInfo info) installing,
    required TResult Function(UpdateInfo info) completed,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? checking,
    TResult? Function(UpdateInfo info)? updateAvailable,
    TResult? Function(String version)? upToDate,
    TResult? Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult? Function(UpdateInfo info)? extracting,
    TResult? Function(UpdateInfo info)? installing,
    TResult? Function(UpdateInfo info)? completed,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? checking,
    TResult Function(UpdateInfo info)? updateAvailable,
    TResult Function(String version)? upToDate,
    TResult Function(UpdateInfo info, int bytesReceived, int totalBytes)?
    downloading,
    TResult Function(UpdateInfo info)? extracting,
    TResult Function(UpdateInfo info)? installing,
    TResult Function(UpdateInfo info)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UpdateInitial value) initial,
    required TResult Function(UpdateChecking value) checking,
    required TResult Function(UpdateIsAvailable value) updateAvailable,
    required TResult Function(UpdateUpToDate value) upToDate,
    required TResult Function(UpdateDownloading value) downloading,
    required TResult Function(UpdateExtracting value) extracting,
    required TResult Function(UpdateInstalling value) installing,
    required TResult Function(UpdateIsCompleted value) completed,
    required TResult Function(UpdateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UpdateInitial value)? initial,
    TResult? Function(UpdateChecking value)? checking,
    TResult? Function(UpdateIsAvailable value)? updateAvailable,
    TResult? Function(UpdateUpToDate value)? upToDate,
    TResult? Function(UpdateDownloading value)? downloading,
    TResult? Function(UpdateExtracting value)? extracting,
    TResult? Function(UpdateInstalling value)? installing,
    TResult? Function(UpdateIsCompleted value)? completed,
    TResult? Function(UpdateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UpdateInitial value)? initial,
    TResult Function(UpdateChecking value)? checking,
    TResult Function(UpdateIsAvailable value)? updateAvailable,
    TResult Function(UpdateUpToDate value)? upToDate,
    TResult Function(UpdateDownloading value)? downloading,
    TResult Function(UpdateExtracting value)? extracting,
    TResult Function(UpdateInstalling value)? installing,
    TResult Function(UpdateIsCompleted value)? completed,
    TResult Function(UpdateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UpdateError implements UpdateState {
  const factory UpdateError(final String message) = _$UpdateErrorImpl;

  String get message;

  /// Create a copy of UpdateState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateErrorImplCopyWith<_$UpdateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
